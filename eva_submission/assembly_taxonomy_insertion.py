from lxml import etree
import requests

from ebi_eva_common_pyutils.pg_utils import get_all_results_for_query
from ebi_eva_common_pyutils.logger import logging_config as log_cfg


logger = log_cfg.get_logger(__name__)


def download_xml_from_ena(accession):
    """Download and parse XML from ENA using any accession or id (e.g. assembly or taxonomy)"""
    try:  # catches any kind of request error, including non-20X status code
        response = requests.get(f'https://www.ebi.ac.uk/ena/browser/api/xml/{accession}')
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        raise e
    root = etree.XML(bytes(response.text, encoding='utf-8'))
    return root


def get_assembly_name_and_taxonomy_id(assembly_accession):
    xml_root = download_xml_from_ena(assembly_accession)
    xml_assembly = xml_root.xpath('/ASSEMBLY_SET/ASSEMBLY')
    if len(xml_assembly) == 0:
        raise Exception(f'Assembly {assembly_accession} not found in ENA')
    assembly_name = xml_assembly[0].get('alias')
    taxonomy_id = int(xml_assembly[0].xpath('TAXON/TAXON_ID')[0].text)
    return assembly_name, taxonomy_id


def get_scientific_name_and_common_name(taxonomy_id):
    xml_root = download_xml_from_ena(taxonomy_id)
    xml_taxon = xml_root.xpath('/TAXON_SET/taxon')
    if len(xml_taxon) == 0:
        raise Exception(f'Taxonomy {taxonomy_id} not found in ENA')
    scientific_name = xml_taxon[0].get('scientificName')
    optional_common_name = xml_taxon[0].get('commonName')
    return scientific_name, optional_common_name


def get_assembly_set(conn, taxonomy, assembly_accession):
    rows = get_all_results_for_query(conn,
                         """SELECT acc.assembly_set_id 
                         FROM evapro.accessioned_assembly acc 
                         JOIN assembly_set asm on acc.assembly_set_id = asm.assembly_set_id 
                         WHERE assembly_accession=\'{}\' AND taxonomy_id={}""".format(assembly_accession, taxonomy))

    if len(rows) == 1:
        return rows[0][0]
    elif len(rows) == 0:
        return None
    else:
        raise Exception('Inconsistent database state: several assembly_set_ids for the same taxonomy ({}) and assembly '
                        'accession ({}): {}'.format(taxonomy, assembly_accession, rows))


def is_taxonomy_in_evapro(conn, taxonomy_id):
    taxonomy_query = 'SELECT taxonomy_id FROM evapro.taxonomy WHERE taxonomy_id={}'.format(taxonomy_id)
    taxonomy_ids_in_evapro = get_all_results_for_query(conn, taxonomy_query)
    return len(taxonomy_ids_in_evapro) > 0


def build_taxonomy_code(scientific_name):
    # Given a scientific name like "Zea mays", the corresponding taxonomy code should be zmays
    return (scientific_name.split(" ")[0][0] + scientific_name.split(" ")[1]).lower()


def ensure_taxonomy_is_in_evapro(conn, taxonomy, eva_species_name):
    if is_taxonomy_in_evapro(conn, taxonomy):
        logger.warning('Taxonomy {} is already in the database'.format(taxonomy))
    else:
        logger.info("Taxonomy {} not present in EVAPRO. Adding taxonomy ...".format(taxonomy))
        scientific_name, common_name = get_scientific_name_and_common_name(taxonomy)
        taxonomy_code = build_taxonomy_code(scientific_name)
        eva_species_name = eva_species_name if eva_species_name is not None else common_name
        if eva_species_name is None:
            raise Exception(
                'The taxonomy in ENA doesn\'t include a common name. '
                'Please specify the EVA name for the species "{}"'.format(scientific_name))
        insert_taxonomy(conn, taxonomy, scientific_name, common_name, taxonomy_code, eva_species_name)


def insert_assembly(conn, taxonomy_id, assembly_accession, assembly_name, assembly_code):
    cur = conn.cursor()
    cur.execute('INSERT INTO evapro.assembly_set(taxonomy_id, assembly_name, assembly_code) VALUES (%s, %s, %s)',
                (taxonomy_id, assembly_name, assembly_code))

    # get the assembly_set_id that was autogenerated in the row that we just inserted in assembly_set
    assembly_set_id = get_all_results_for_query(conn,
                                    'SELECT assembly_set_id FROM evapro.assembly_set '
                                    'WHERE taxonomy_id={} and assembly_name=\'{}\' and assembly_code=\'{}\''
                                    .format(taxonomy_id, assembly_name, assembly_code))[0][0]

    assembly_chain = assembly_accession.split('.')[0]
    assembly_version = assembly_accession.split('.')[1]
    cur.execute('INSERT INTO evapro.accessioned_assembly('
                'assembly_set_id, assembly_accession, assembly_chain, assembly_version) VALUES (%s,%s,%s,%s)',
                (assembly_set_id, assembly_accession, assembly_chain, assembly_version))

    logger.info('New assembly added with assembly_set_id: {0}'.format(assembly_set_id))
    return assembly_set_id


def update_accessioning_status(conn, assembly_accession, in_accessioning_flag):
    cur = conn.cursor()
    # Only insert assembly accessions which are NOT already in the assembly_accessioning_store_status table
    assembly_accessioning_store_insert_query = "INSERT INTO evapro.assembly_accessioning_store_status " \
                                               "SELECT * FROM (SELECT " \
                                               "cast('{0}' as text) as assembly_accession" \
                                               ", cast('{1}' as boolean) as loaded) temp " \
                                               "WHERE assembly_accession NOT IN " \
                                               "(SELECT assembly_accession FROM " \
                                               "evapro.assembly_accessioning_store_status)" \
                                               .format(assembly_accession, in_accessioning_flag)
    cur.execute(assembly_accessioning_store_insert_query)


def insert_taxonomy(conn, taxonomy_id, scientific_name, common_name, taxonomy_code, eva_species_name):
    if taxonomy_code is None or eva_species_name is None:
        raise Exception('Error: taxonomy code ({}) and EVA taxonomy name ({}) are required '
                        'for inserting a taxonomy'.format(taxonomy_code, eva_species_name))
    cur = conn.cursor()
    cur.execute('INSERT INTO evapro.taxonomy(taxonomy_id, common_name, scientific_name, taxonomy_code, eva_name) '
                'VALUES (%s, %s, %s, %s, %s)',
                (taxonomy_id, common_name, scientific_name, taxonomy_code, eva_species_name))
    logger.info('New taxonomy {} added'.format(taxonomy_id))


def get_assembly_code_from_db_name(db_name):
    """
    Gets assembly code (e.g. galgal5) from database name (e.g. eva_ggallus_galgal5).
    NB. will be obsolete once we change db naming conventions.
    """
    return db_name.split('_')[-1]


def insert_new_assembly_and_taxonomy(
        assembly_accession,
        db_name,
        conn,
        taxonomy_id,
        eva_species_name=None,
        in_accessioning=True
):
    """
    This script adds new assemblies and taxonomies to EVAPRO.
    If you provide the assembly accession and the assembly code, the script will
    try to add them linked to the official taxonomy as described in ENA.
    Example assembly page: https://www.ebi.ac.uk/ena/data/view/GCA_000002315.3
    You can also add the assembly with a different taxonomy if you provide the
    taxonomy parameters. Example taxonomy page:
    https://www.ebi.ac.uk/ena/data/view/Taxon:9031

    :param assembly_accession: Assembly accession (Example: GCA_000002315.3)
    :param db_name: Variant DB name to use (Example: eva_ggallus_galgal5)
    :param conn: Metadata DB connection
    :param taxonomy_id: Taxonomy id (Example: 9031)
    :param eva_species_name: EVA species name (Example: chicken).
        Not required if the taxonomy exists or ENA has a common name available.
    :param in_accessioning: Flag that this assembly is in the accessioning data store.
    :return:
    """
    # check if assembly is already in EVAPRO, adding it if not
    assembly_name, official_taxonomy = get_assembly_name_and_taxonomy_id(assembly_accession)
    if taxonomy_id is not None:
        if taxonomy_id != official_taxonomy:
            logger.warning("Adding taxonomy {} for assembly {}, although the standard taxonomy is {}".format(
                taxonomy_id, assembly_accession, official_taxonomy))
    else:
        taxonomy_id = official_taxonomy

    assembly_set_id = get_assembly_set(conn, taxonomy_id, assembly_accession)
    if assembly_set_id is not None:
        logger.warning("Assembly set id {} already links taxonomy {} and assembly {}".format(
            assembly_set_id, taxonomy_id, assembly_accession))
    else:
        ensure_taxonomy_is_in_evapro(conn, taxonomy_id, eva_species_name)
        assembly_code = get_assembly_code_from_db_name(db_name)
        insert_assembly(conn, taxonomy_id, assembly_accession, assembly_name, assembly_code)

    update_accessioning_status(conn, assembly_accession, in_accessioning)
    conn.commit()
